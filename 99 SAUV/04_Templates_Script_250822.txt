// Fichier gÃ©nÃ©rÃ© le 22/08/2025 Ã  10:37:26

// --- DÃ©but du fichier: TraitementReponses.js ---
// =================================================================================
// == FICHIER : TraitementReponses.gs
// == VERSION : 19.4 (Nettoyage automatique des ID de piÃ¨ces jointes)
// == RÃ”LE  : GÃ¨re la logique de traitement des rÃ©ponses et aiguille vers le bon moteur.
// =================================================================================

/**
 * Nettoie une chaÃ®ne de caractÃ¨res pour la rendre utilisable comme nom de variable/placeholder.
 */
function _nettoyerEnTete(enTete) {
  if (!enTete) return "";
  const accents = 'Ã€ÃÃ‚ÃƒÃ„Ã…Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã’Ã“Ã”Ã•Ã–Ã˜Ã²Ã³Ã´ÃµÃ¶Ã¸ÃˆÃ‰ÃŠÃ‹Ã¨Ã©ÃªÃ«Ã‡Ã§ÃŒÃÃŽÃÃ¬Ã­Ã®Ã¯Ã™ÃšÃ›ÃœÃ¹ÃºÃ»Ã¼Ã¿Ã‘Ã±';
  const sansAccents = 'AAAAAAaaaaaaOOOOOOooooooEEEEeeeeCcIIIIiiiiUUUUuuuuyNn';
  return enTete.toString().split('').map((char) => {
    const accentIndex = accents.indexOf(char);
    return accentIndex !== -1 ? sansAccents[accentIndex] : char;
  }).join('')
  .replace(/[^a-zA-Z0-9_]/g, '_');
}

/**
 * CrÃ©e un objet de rÃ©ponse standardisÃ© Ã  partir d'un numÃ©ro de ligne.
 */
function _creerObjetReponse(rowIndex) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheets()[0];
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const rowValues = sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).getValues()[0];
  const reponse = {};

  headers.forEach((header, i) => {
    let cle = header;
    if (header && !header.includes(':')) {
      cle = _nettoyerEnTete(header);
    }
    if (cle) {
      reponse[cle] = rowValues[i];
    }
  });
  return reponse;
}

/**
 * Point d'entrÃ©e principal pour traiter une soumission de formulaire.
 */
function onFormSubmit(e) {
  try {
    const rowIndex = e.range.getRow();
    traiterLigne(rowIndex, {});
  } catch (err) {
    Logger.log(`Erreur critique dans onFormSubmit pour la ligne ${e.range.getRow()}: ${err.toString()}\n${err.stack}`);
  }
}

/**
 * Envoie un e-mail de confirmation.
 */
function _envoyerEmailDeConfirmation(config, reponse, langueCible) {
    try {
        const nomColonneOverride = `ID_Gabarit_Email_Confirmation_${langueCible}`;
        let idGabaritConfirmation = config[nomColonneOverride];
        if (!idGabaritConfirmation || String(idGabaritConfirmation).trim() === '') {
            const systemIds = getSystemIds();
            const nomCleDefaut = `ID_GABARIT_CONFIRMATION_${langueCible}`;
            idGabaritConfirmation = systemIds[nomCleDefaut];
            Logger.log(`Utilisation du gabarit de confirmation PAR DÃ‰FAUT pour la langue ${langueCible}.`);
        } else {
            Logger.log(`Utilisation du gabarit de confirmation SPÃ‰CIFIQUE pour la langue ${langueCible}.`);
        }
        const emailRepondant = reponse.Votre_adresse_e_mail || reponse.Adresse_e_mail || reponse.emailRepondant;
        if (!idGabaritConfirmation || String(idGabaritConfirmation).trim() === '' || !emailRepondant) {
            Logger.log(`Aucun e-mail de confirmation Ã  envoyer pour la langue ${langueCible}.`);
            return;
        }
        const doc = DocumentApp.openById(idGabaritConfirmation);
        let sujet = doc.getName();
        const url = "https://docs.google.com/feeds/download/documents/export/Export?id=" + idGabaritConfirmation + "&exportFormat=html";
        const token = ScriptApp.getOAuthToken();
        const response = UrlFetchApp.fetch(url, { headers: { 'Authorization': 'Bearer ' + token } });
        let corpsHtml = response.getContentText();
        for (const key in reponse) {
            if (reponse.hasOwnProperty(key)) {
                const placeholder = `{{${key}}}`;
                const valeur = reponse[key] || '';
                const regex = new RegExp(placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
                sujet = sujet.replace(regex, valeur);
                corpsHtml = corpsHtml.replace(regex, valeur);
            }
        }
        const mailOptions = { to: emailRepondant, subject: sujet, htmlBody: corpsHtml };
        if (config.Email_Alias && config.Email_Alias.trim() !== '') {
            mailOptions.from = config.Email_Alias;
        }
        GmailApp.sendEmail(mailOptions.to, mailOptions.subject, "", mailOptions);
        Logger.log(`E-mail de confirmation [${langueCible}] envoyÃ© avec succÃ¨s Ã  ${emailRepondant}.`);
    } catch (e) {
        Logger.log(`ERREUR lors de l'envoi de l'e-mail de confirmation : ${e.toString()}\n${e.stack}`);
    }
}

/**
 * COEUR LOGIQUE : Aiguille le traitement vers le moteur.
 */
function traiterLigne(rowIndex, optionsSurcharge = {}) {
  try {
    const config = getTestConfiguration();
    const reponse = _creerObjetReponse(rowIndex);
    
    const langueOrigine = getOriginalLanguage(reponse);
    const langueCible = optionsSurcharge.langue || langueOrigine;
    
    if (!optionsSurcharge.isRetraitement) {
      _envoyerEmailDeConfirmation(config, reponse, langueCible);
    }
    
    const resultats = calculerResultats(reponse, langueCible, config, langueOrigine);

    if (optionsSurcharge.isRetraitement || config.Repondant_Quand === 'Immediat') {
      if (config.Moteur_Calcul === 'Universel') {
        Logger.log("Moteur UNIVERSEL dÃ©tectÃ© pour la ligne " + rowIndex + ". Envoi immÃ©diat (retraitement ou configuration).");
        assemblerEtEnvoyerEmailUniversel(config, reponse, resultats, langueCible, optionsSurcharge);
      } else {
        // Moteur legacy...
      }
    } else {
      Logger.log(`Envoi diffÃ©rÃ© dÃ©tectÃ©. Valeur : "${config.Repondant_Quand}". Lancement de la programmation.`);
      programmerEnvoiResultats(rowIndex, langueCible, config.Repondant_Quand);
    }

  } catch (err) {
    Logger.log("ERREUR FATALE dans traiterLigne: " + err.toString() + "\n" + err.stack);
  }
}

// =================================================================================
// == MOTEUR UNIVERSEL - FONCTION D'ENVOI D'EMAIL
// =================================================================================
/**
 * Lit la BDD, assemble et envoie l'e-mail de rÃ©sultats.
 */
function assemblerEtEnvoyerEmailUniversel(config, reponse, resultats, langueCible, optionsSurcharge = {}) {
  const typeTest = config.Type_Test;
  let codeNiveauEmail = config.ID_Gabarit_Email_Repondant.replace('RESULTATS_', '');

  if (optionsSurcharge && optionsSurcharge.niveau && optionsSurcharge.niveau !== '') {
    codeNiveauEmail = optionsSurcharge.niveau;
  }

  const profilFinal = resultats.profilFinal;
  const systemIds = getSystemIds();
  const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
  const compoSheet = bdd.getSheetByName("sys_Composition_Emails");
  const compoData = compoSheet.getDataRange().getValues();
  const compoHeaders = compoData.shift();
  const idx = {
    typeTest: compoHeaders.indexOf('Type_Test'),
    langue: compoHeaders.indexOf('Code_Langue'),
    niveau: compoHeaders.indexOf('Code_Niveau_Email'),
    profil: compoHeaders.indexOf('Code_Profil'),
    element: compoHeaders.indexOf('Element'),
    ordre: compoHeaders.indexOf('Ordre'),
    contenu: compoHeaders.indexOf('Contenu / ID_Document')
  };

  let briquesDeContenu = compoData.filter(row => {
    const typeLigne = (row[idx.typeTest] || '').trim();
    const typeCible = (typeTest || '').trim();
    const typeMatch = (typeLigne === typeCible || typeLigne === '');
    const langMatch = row[idx.langue] === langueCible;
    const levelMatch = row[idx.niveau].includes(codeNiveauEmail);
    const profilLigne = (row[idx.profil] || '').trim();
    const profilCible = (profilFinal || '').trim();
    const profileMatch = (profilLigne === profilCible || profilLigne === '');
    return typeMatch && langMatch && levelMatch && profileMatch;
  });

  briquesDeContenu.sort((a, b) => a[idx.ordre] - b[idx.ordre]);
  
  let contenuInfoCopie = null;
  const indexInfoCopie = briquesDeContenu.findIndex(brique => (brique[idx.element] || '').trim() === 'Info_Copie');
  if (indexInfoCopie > -1) {
    contenuInfoCopie = briquesDeContenu[indexInfoCopie][idx.contenu];
    briquesDeContenu.splice(indexInfoCopie, 1);
  }

  let sujet = `RÃ©sultats de votre test ${typeTest}`;
  let corpsHtml = "";
  const piecesJointesIds = new Set();

  for (const brique of briquesDeContenu) {
    const elementType = (brique[idx.element] || '').trim();
    const contenu = brique[idx.contenu];
    switch (elementType) {
      case 'Sujet_Email': sujet = contenu; break;
      case 'Introduction': case 'Corps_Texte': corpsHtml += contenu + "<br>"; break;
      // ==================== DÃ‰BUT DE LA MODIFICATION (ROBUSTESSE ID) ====================
      case 'Document':
        // On s'assure que l'ID est une chaÃ®ne de caractÃ¨res et on nettoie les espaces/sauts de ligne
        if (contenu && String(contenu).trim()) {
          piecesJointesIds.add(String(contenu).trim());
        }
        break;
      // ===================== FIN DE LA MODIFICATION (ROBUSTESSE ID) =====================
      case 'Ligne_Score':
        Object.entries(resultats.scoresData).sort((a, b) => b[1] - a[1]).forEach(([code, score]) => {
          let ligneScore = contenu.replace(/{{nom_profil}}/g, resultats.mapCodeToName[code] || code).replace(/{{score}}/g, score);
          corpsHtml += ligneScore + "<br>";
        });
        break;
    }
  }

  const donneesPourEmail = { ...reponse, ...resultats };
  for (const key in donneesPourEmail) {
    if (donneesPourEmail.hasOwnProperty(key)) {
      const placeholder = `{{${key}}}`;
      const valeur = donneesPourEmail[key] || '';
      const regex = new RegExp(placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
      sujet = sujet.replace(regex, valeur);
      corpsHtml = corpsHtml.replace(regex, valeur);
      if (contenuInfoCopie) {
        contenuInfoCopie = contenuInfoCopie.replace(regex, valeur);
      }
    }
  }

  const piecesJointes = Array.from(piecesJointesIds).map(id => {
    let blob = null;
    for (let i = 0; i < 3; i++) { // Tentative de 3 essais
      try {
        blob = DriveApp.getFileById(id).getBlob();
        break; // SuccÃ¨s, on sort de la boucle
      } catch (e) {
        Logger.log(`Tentative ${i + 1} Ã©chouÃ©e pour la PJ : ${id}. Erreur: ${e.message}`);
        if (i < 2) { // Si ce n'est pas la derniÃ¨re tentative
          Utilities.sleep(1000); // On attend 1 seconde avant de rÃ©essayer
        } else {
          Logger.log(`ERREUR FINALE PJ : Impossible d'attacher le fichier ${id} aprÃ¨s 3 tentatives.`);
        }
      }
    }
    return blob;
  }).filter(Boolean);

  const T = loadTraductions(langueCible);
  const adressesUniques = new Set();
  const emailRepondantPrincipal = reponse.Votre_adresse_e_mail || reponse.Adresse_e_mail || reponse.emailRepondant;
  
  const destinatairesSurcharge = optionsSurcharge.destinataires || {};
  const useSurcharge = Object.keys(destinatairesSurcharge).length > 0;

  if (useSurcharge) {
    if (destinatairesSurcharge.repondant && emailRepondantPrincipal) { adressesUniques.add(emailRepondantPrincipal); }
    if (destinatairesSurcharge.formateur && destinatairesSurcharge.formateurEmail) { adressesUniques.add(destinatairesSurcharge.formateurEmail); }
    if (destinatairesSurcharge.patron && destinatairesSurcharge.patronEmail) { adressesUniques.add(destinatairesSurcharge.patronEmail); }
    if (destinatairesSurcharge.test && destinatairesSurcharge.test.trim() !== '') {
      destinatairesSurcharge.test.split(',').map(e => e.trim()).forEach(email => adressesUniques.add(email));
    }
  } else {
    if (config.Repondant_Email_Actif === 'Oui' && emailRepondantPrincipal) { adressesUniques.add(emailRepondantPrincipal); }
    if (config.Patron_Email_Mode === 'Oui' && config.Patron_Email) { adressesUniques.add(config.Patron_Email); }
    if (config.Formateur_Email_Actif === 'Oui' && config.Formateur_Email) { adressesUniques.add(config.Formateur_Email); }
  }
  
  if (config.Developpeur_Email) { adressesUniques.add(config.Developpeur_Email); }

  adressesUniques.forEach(adresse => {
    try {
      let sujetFinal = sujet;
      let corpsHtmlFinal = corpsHtml;
      if (adresse.toLowerCase() !== (emailRepondantPrincipal || "").toLowerCase()) {
        sujetFinal = (T.PREFIXE_COPIE_EMAIL || "Copie : ") + sujet;
        if (contenuInfoCopie) { corpsHtmlFinal = contenuInfoCopie + corpsHtml; }
      }
      const mailOptions = { to: adresse, subject: sujetFinal, htmlBody: corpsHtmlFinal, attachments: piecesJointes };
      const aliasExpediteur = optionsSurcharge.alias || config.Email_Alias;
      if (aliasExpediteur && aliasExpediteur.trim() !== '') {
        mailOptions.from = aliasExpediteur;
      }
      GmailApp.sendEmail(mailOptions.to, mailOptions.subject, "", mailOptions);
      Logger.log(`E-mail de RÃ‰SULTATS [${langueCible}] envoyÃ© avec succÃ¨s Ã  ${adresse}.`);
    } catch (e) {
      Logger.log(`Echec de l'envoi des rÃ©sultats Ã  ${adresse}. Erreur: ${e.message}`);
    }
  });
}

// =================================================================================
// == SECTION INTERFACE UTILISATEUR (UI)
// =================================================================================

function getDonneesPourRetraitement(rowIndex) {
  try {
    const config = getTestConfiguration();
    const reponse = _creerObjetReponse(rowIndex);

    const nomRepondant = reponse.Votre_nom_et_prenom || reponse.Nom_et_prenom || '';
    const emailRepondant = reponse.Votre_adresse_e_mail || reponse.Adresse_e_mail || '';
    
    return {
      nomRepondant: nomRepondant,
      emailRepondant: emailRepondant,
      langueOrigine: getOriginalLanguage(reponse),
      repondantActif: config.Repondant_Email_Actif === 'Oui',
      formateurActif: config.Formateur_Email_Actif === 'Oui',
      patronActif: config.Patron_Email_Mode === 'Oui',
      emailAlias: config.Email_Alias || ''
    };
  } catch (e) {
    Logger.log(`ERREUR dans getDonneesPourRetraitement(${rowIndex}): ${e.toString()}`);
    throw new Error("Impossible de rÃ©cupÃ©rer les donnÃ©es pour la ligne " + rowIndex + ". " + e.message);
  }
}

/**
 * Lance le retraitement depuis l'interface utilisateur.
 */
function lancerRetraitementDepuisUI(options) {
  if (!options || !options.rowIndex) {
    throw new Error("Les options de retraitement sont invalides.");
  }

  options.isRetraitement = true; 
  
  traiterLigne(options.rowIndex, options);
  
  return "Retraitement pour la ligne " + options.rowIndex + " lancÃ© avec succÃ¨s !";
}
// --- Fin du fichier: TraitementReponses.js ---

// --- DÃ©but du fichier: Utilities.js ---
// =================================================================================
// == FICHIER : Utilities.gs
// == VERSION : 8.2 (Robustesse de la dÃ©tection de colonne de langue)
// == RÃ”LE  : BoÃ®te Ã  outils du Kit de Traitement.
// =================================================================================

const ID_FEUILLE_PILOTE = "1kLBqIHZWbHrb4SsoSQcyVsLOmqKHkhSA4FttM5hZtDQ";

/**
 * RÃ©cupÃ¨re la ligne de configuration complÃ¨te pour le test en cours.
 */
function getTestConfiguration() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const idSheetActuelle = ss.getId();
  const piloteSheet = SpreadsheetApp.openById(ID_FEUILLE_PILOTE);
  const paramsSheet = piloteSheet.getSheetByName("ParamÃ¨tres GÃ©nÃ©raux");
  if (!paramsSheet) { throw new Error("L'onglet 'ParamÃ¨tres GÃ©nÃ©raux' est introuvable."); }
  const data = paramsSheet.getDataRange().getValues();
  const headers = data.shift();
  const idSheetColIndex = headers.indexOf('ID_Sheet_Cible');
  if (idSheetColIndex === -1) { throw new Error("La colonne 'ID_Sheet_Cible' est introuvable."); }
  const configRow = data.find(row => row[idSheetColIndex] === idSheetActuelle);
  if (!configRow) { throw new Error("Impossible de trouver la configuration pour ce test (ID: " + idSheetActuelle + ").");}
  const configuration = {};
  headers.forEach((header, index) => {
    if (header) { configuration[header] = configRow[index]; }
  });
  return configuration;
}

/**
 * Lit l'onglet 'sys_ID_Fichiers' de la feuille de configuration centrale.
 */
function getSystemIds() {
  try {
    const configSS = SpreadsheetApp.openById(ID_FEUILLE_PILOTE);
    const idSheet = configSS.getSheetByName('sys_ID_Fichiers');
    if (!idSheet) { throw new Error("L'onglet 'sys_ID_Fichiers' est introuvable."); }
    const data = idSheet.getDataRange().getValues();
    const ids = {};
    data.slice(1).forEach(row => {
      if (row[0] && row[1]) { ids[row[0]] = row[1]; }
    });
    return ids;
  } catch (e) {
    Logger.log("Impossible de charger les ID systÃ¨me : " + e.toString());
    throw new Error("Impossible de charger les ID systÃ¨me. Erreur: " + e.message);
  }
}

/**
 * DÃ©tecte correctement la langue de la rÃ©ponse initiale de l'utilisateur.
 */
function getOriginalLanguage(reponses) {
  const langueRepondantBrute = reponses['Langue___Language'] || reponses['Langue / Language'] || 'FranÃ§ais';
  const mapLangue = { 'FranÃ§ais': 'FR', 'English': 'EN', 'EspaÃ±ol': 'ES', 'Deutsch': 'DE' };
  return mapLangue[langueRepondantBrute] || 'FR';
}

function getGabaritEmail(idGabarit, langueCode) {
  const systemIds = getSystemIds();
  const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
  const gabaritsSheet = bdd.getSheetByName("Gabarits_Emails");
  if (!gabaritsSheet) throw new Error("L'onglet 'Gabarits_Emails' est introuvable.");
  const data = gabaritsSheet.getDataRange().getValues();
  const headers = data.shift();
  const idCol = headers.indexOf('ID_Gabarit');
  const langCol = headers.indexOf('Langue');
  const gabaritRow = data.find(row => row[idCol] === idGabarit && row[langCol].toUpperCase() === langueCode.toUpperCase());
  if (!gabaritRow) throw new Error(`Aucun gabarit trouvÃ© pour l'ID '${idGabarit}' et la langue '${langueCode}'.`);

  const gabarit = {};
  headers.forEach((header, index) => {
    if (header) { gabarit[header] = gabaritRow[index]; }
  });
  return gabarit;
}

function formatScoresDetails(resultats, niveauDetails, typeTest, langueCode) {
  if (niveauDetails === 'Simple' || !resultats.scoresData || Object.keys(resultats.scoresData).length === 0) {
    return "";
  }
  try {
    const systemIds = getSystemIds();
    const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
    const formatSheet = bdd.getSheetByName("sys_Formatage_Scores");
    if (!formatSheet) return "Erreur: Onglet 'sys_Formatage_Scores' introuvable.\n";
    const formatData = formatSheet.getDataRange().getValues();
    const formatHeaders = formatData.shift();
    const typeTestCol = formatHeaders.indexOf('Type_Test');
    const regle = formatData.find(row => row[typeTestCol] === typeTest);
    if (!regle) return `Aucune rÃ¨gle d'affichage trouvÃ©e pour le test '${typeTest}'.\n`;
    const regleMap = {};
    formatHeaders.forEach((h, i) => regleMap[h] = regle[i]);
    const T = loadTraductions(langueCode);
    let scoresText = (regleMap.Texte_Intro || "Voici le dÃ©tail de vos scores :") + "\n";
    if (regleMap.Mode_Affichage === 'Simple') {
      let scoresArray = Object.entries(resultats.scoresData).map(([code, score]) => ({
        code_profil: code,
        nom_profil: resultats.mapCodeToName[code] || code,
        score: score
      }));
      if (regleMap.Tri_Scores === 'DÃ©croissant') {
        scoresArray.sort((a, b) => b.score - a.score);
      } else if (regleMap.Tri_Scores === 'Croissant') {
        scoresArray.sort((a, b) => a.score - b.score);
      }
      scoresArray.forEach(item => {
        let ligne = regleMap.Format_Ligne.replace(/{{nom_profil}}/g, item.nom_profil)
          .replace(/{{score}}/g, item.score)
          .replace(/{{suffixe_points}}/g, T.SUFFIXE_POINTS || 'points');
        scoresText += ligne + "\n";
      });
    } else if (regleMap.Mode_Affichage === 'Dichotomie') {
      const axes = [
        { nom: (T.AXE_EI || "Extraversion (E) vs Introversion (I)"), p1: 'E', p2: 'I' },
        { nom: (T.AXE_SN || "Sensation (S) vs Intuition (N)"),  p1: 'S', p2: 'N' },
        { nom: (T.AXE_TF || "PensÃ©e (T) vs Sentiment (F)"),    p1: 'T', p2: 'F' },
        { nom: (T.AXE_JP || "Jugement (J) vs Perception (P)"),  p1: 'J', p2: 'P' }
      ];
      axes.forEach(axe => {
        let ligne = regleMap.Format_Ligne.replace(/{{axe_nom}}/g, axe.nom)
          .replace(/{{score1}}/g, resultats.scoresData[axe.p1] || 0)
          .replace(/{{score2}}/g, resultats.scoresData[axe.p2] || 0);
        scoresText += ligne + "\n";
      });
    }
    return scoresText;
  } catch (e) {
    Logger.log(`ERREUR CRITIQUE DANS formatScoresDetails (universel): ${e.toString()}`);
    return "Impossible d'afficher le dÃ©tail des scores en raison d'une erreur.\n";
  }
}

/**
 * Charge les chaÃ®nes de caractÃ¨res traduites pour une langue donnÃ©e.
 * @version CORRIGÃ‰E : Utilise .trim() pour ignorer les espaces dans les en-tÃªtes.
 */
function loadTraductions(langueCode) {
  if (!langueCode) {
    throw new Error("Le code de langue fourni Ã  loadTraductions est indÃ©fini.");
  }
  const systemIds = getSystemIds();
  const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
  const traductionsSheet = bdd.getSheetByName("traductions");
  if (!traductionsSheet) throw new Error("L'onglet 'traductions' est introuvable.");
  const data = traductionsSheet.getDataRange().getValues();
  const headers = data.shift();
  // MODIFICATION : Ajout de .trim() pour ignorer les espaces avant/aprÃ¨s les noms de colonnes (ex: " en " au lieu de "en")
  const langColIndex = headers.findIndex(h => h && h.trim().toLowerCase() === langueCode.toLowerCase());
  if (langColIndex === -1) throw new Error(`La colonne de langue '${langueCode}' est introuvable dans l'onglet "traductions".`);
  const traductions = {};
  const keyColIndex = 0;
  data.forEach(row => {
    if (row[keyColIndex]) { traductions[row[keyColIndex]] = row[langColIndex]; }
  });
  return traductions;
}

function buildAndSendEmails(config, reponse, resultats, langueCode, isDebugMode, destinatairesSurcharge = {}) {
  try {
    const idGabarit = config.ID_Gabarit_Email_Repondant;
    if (!idGabarit) {
      throw new Error("La colonne 'ID_Gabarit_Email_Repondant' n'est pas dÃ©finie dans la configuration du test.");
    }
    const gabarit = getGabaritEmail(idGabarit, langueCode);
    const T = loadTraductions(langueCode);
    const variables = {
      nom_repondant: reponse.nomRepondant || 'Participant',
      Type_Test: config.Type_Test || '',
      profil_titre: resultats.titreProfil || resultats.profilFinal || '',
      profil_description: resultats.descriptionProfil || 'Aucune description disponible.',
      scores_details: formatScoresDetails(resultats, gabarit.Niveau_Details_Resultats, config.Type_Test, langueCode).replace(/\n/g, '<br>'),
      formateur_nom: config.Formateur_Nom || 'Votre Formateur',
      formateur_consultant: gabarit.formateur_consultant || 'Votre Consultant CertifiÃ©'
    };
    let corpsHtml = gabarit.Corps_HTML;
    if (!corpsHtml) {
      throw new Error(`Le gabarit d'e-mail '${idGabarit}' n'a pas de contenu dans la colonne 'Corps_HTML'.`);
    }

    let sujet = gabarit.Sujet;
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`\\{${key}\\}`, 'g');
      sujet = sujet.replace(regex, value);
      corpsHtml = corpsHtml.replace(regex, value);
    }

    const piecesJointes = findAttachments(config.Type_Test, resultats.profilFinal, gabarit.Niveau_Pieces_Jointes, langueCode);
    const adressesUniques = new Set();
    const useSurcharge = destinatairesSurcharge && Object.keys(destinatairesSurcharge).length > 0;
    if (useSurcharge) {
      if (destinatairesSurcharge.repondant && reponse.emailRepondant) { adressesUniques.add(reponse.emailRepondant); }
      if (destinatairesSurcharge.formateur && destinatairesSurcharge.formateurEmail) { adressesUniques.add(destinatairesSurcharge.formateurEmail); }
      if (destinatairesSurcharge.patron && destinatairesSurcharge.patronEmail) { adressesUniques.add(destinatairesSurcharge.patronEmail); }
      if (destinatairesSurcharge.test && destinatairesSurcharge.test.trim() !== '') {
        const testEmails = destinatairesSurcharge.test.split(',').map(e => e.trim());
        testEmails.forEach(email => adressesUniques.add(email));
      }
    } else {
      if (config.Repondant_Email_Actif === 'Oui' && reponse.emailRepondant) { adressesUniques.add(reponse.emailRepondant); }
      if (config.Patron_Email_Mode === 'Oui' && config.Patron_Email) { adressesUniques.add(config.Patron_Email); }
      if (config.Formateur_Email_Actif === 'Oui' && config.Formateur_Email) { adressesUniques.add(config.Formateur_Email); }
    }
    if (config.Developpeur_Email) { adressesUniques.add(config.Developpeur_Email); }
    adressesUniques.forEach(adresse => {
      try {
        let sujetFinal = sujet;
        if (adresse.toLowerCase() !== (reponse.emailRepondant || "").toLowerCase()) {
          sujetFinal = (T.PREFIXE_COPIE_EMAIL || "Copie : ") + sujet;
        }
        MailApp.sendEmail({
          to: adresse,
          subject: sujetFinal,
          htmlBody: corpsHtml,
          attachments: piecesJointes
        });
      } catch (e) {
        Logger.log(`Echec de l'envoi Ã  ${adresse}. Erreur: ${e.message}`);
      }
    });
  } catch (err) {
    Logger.log("ERREUR CRITIQUE dans buildAndSendEmails : " + err.toString() + "\n" + err.stack);
  }
}

function findAttachments(typeTest, profilCode, niveauPJ, langueCode) {
  try {
    const systemIds = getSystemIds();
    const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
    const pjSheet = bdd.getSheetByName("sys_PiecesJointes");
    if (!pjSheet) { return []; }
    const data = pjSheet.getDataRange().getValues();
    const headers = data.shift();
    const idx = {
      type: headers.indexOf('Type_Test'),
      profil: headers.indexOf('Profil_Code'),
      niveau: headers.indexOf('Email_Niveau'),
      langue: headers.indexOf('Langue'),
      id: headers.indexOf('ID_Fichier_Drive')
    };
    if (Object.values(idx).some(i => i === -1)) {
      Logger.log("Avertissement : une ou plusieurs colonnes sont manquantes dans 'sys_PiecesJointes'.");
      return [];
    }

    const niveauNumRequis = parseInt(String(niveauPJ).replace(/[^0-9]/g, ''), 10) || 1;
    const idsFichiersTrouves = new Set();
    data.forEach(row => {
      const typeSheet = row[idx.type] ? row[idx.type].toString().toUpperCase() : '';
      const typeTestUpper = typeTest ? typeTest.toUpperCase() : '';
      const typeMatch = (typeSheet === typeTestUpper);
      const profilSheet = row[idx.profil] ? row[idx.profil].toString().toUpperCase() : '';
      const profilCodeUpper = profilCode ? profilCode.toUpperCase() : '';
      const profilMatch = (profilSheet === profilCodeUpper || profilSheet === 'TOUS');
      const langueSheet = row[idx.langue] ? row[idx.langue].toString().toUpperCase() : '';
      const langueCodeUpper = langueCode ? langueCode.toUpperCase() : '';
      const langueMatch = (langueSheet === langueCodeUpper || langueSheet === 'TOUS');

      const niveauMatch = (row[idx.niveau] > 0 && row[idx.niveau] <= niveauNumRequis);

      if (typeMatch && profilMatch && niveauMatch && langueMatch && row[idx.id]) {
        idsFichiersTrouves.add(row[idx.id]);
      }
    });
    if (idsFichiersTrouves.size === 0) return [];
    const fichiers = [];
    idsFichiersTrouves.forEach(id => {
      try {
        fichiers.push(DriveApp.getFileById(id).getBlob());
      } catch (e) {
        Logger.log(`Impossible d'accÃ©der au fichier Drive avec l'ID : ${id}`);
      }
    });
    return fichiers;
  } catch (e) {
    Logger.log(`Erreur critique dans findAttachments : ${e.toString()}`);
    return [];
  }
}

function mapQuestionsById(bdd, nomFeuille) {
  const sheet = bdd.getSheetByName(nomFeuille);
  if (!sheet) { throw new Error(`Feuille de questions '${nomFeuille}' introuvable.`); }
  const data = sheet.getDataRange().getValues();
  const headers = data.shift();
  const idCol = headers.indexOf('ID');
  const paramsCol = headers.indexOf('ParamÃ¨tres (JSON)');
  const mapById = {};
  data.forEach(row => {
    const qId = row[idCol];
    if (qId) {
      mapById[qId] = { id: qId, params: row[paramsCol] };
    }
  });
  return mapById;
}
// --- Fin du fichier: Utilities.js ---

// --- DÃ©but du fichier: Logique_Universel.js ---
// =================================================================================
// == FICHIER : Logique_Universel.gs
// == VERSION : 7.0 (Chargement dynamique de toutes les colonnes de profil)
// == RÃ”LE  : Moteur de calcul universel capable de traiter n'importe quel test.
// =================================================================================

/**
 * Fonction principale du moteur universel. GÃ¨re la logique multilingue.
 * @param {object} reponsesUtilisateur - Les rÃ©ponses lues depuis la feuille.
 * @param {string} langueCible - La langue demandÃ©e pour le rÃ©sultat (ex: 'EN').
 * @param {object} config - La configuration du test.
 * @param {string} langueOrigine - La langue dans laquelle l'utilisateur a rÃ©pondu (ex: 'FR').
 * @returns {object} Un objet contenant toutes les donnÃ©es du rÃ©sultat, y compris les colonnes du profil.
 */
function calculerResultats(reponsesUtilisateur, langueCible, config, langueOrigine) {
  // Initialisation simple de l'objet de rÃ©sultats
  let resultats = {
    scoresData: {},
    sousTotauxParMode: {}
  };

  const profilsMap = _chargerProfils(config.Type_Test, langueCible);
  const questionsMapCible = _chargerQuestions(config.Type_Test, langueCible);
  if (!questionsMapCible) return {}; // SÃ©curitÃ©

  if (langueOrigine === langueCible) {
    _executerCalcul(reponsesUtilisateur, questionsMapCible, resultats);
  } else {
    // La logique de traduction complexe reste inchangÃ©e...
    const questionsMapOrigine = _chargerQuestions(config.Type_Test, langueOrigine);
    if (!questionsMapOrigine) return {};

    for (const enTeteComplet in reponsesUtilisateur) {
      if (!enTeteComplet.includes(':')) continue;
      const idQuestion = enTeteComplet.split(':')[0].trim();
      const questionConfigCible = questionsMapCible[idQuestion];

      if (questionConfigCible) {
        if (questionConfigCible.parametres.mode === 'ECHELLE_NOTE') {
          _aiguillerCalcul(questionConfigCible.parametres.mode, reponsesUtilisateur[enTeteComplet], questionConfigCible.parametres, resultats);
        } else {
          const questionConfigOrigine = questionsMapOrigine[idQuestion];
          if (questionConfigOrigine && questionConfigOrigine.parametres.options) {
            const reponseTexte = reponsesUtilisateur[enTeteComplet];
            const reponsesArray = String(reponseTexte).split(',').map(r => r.trim());

            reponsesArray.forEach(reponseSimple => {
              const optionIndex = questionConfigOrigine.parametres.options.findIndex(opt => opt.libelle === reponseSimple);
              if (optionIndex !== -1 && questionConfigCible.parametres.options && questionConfigCible.parametres.options[optionIndex]) {
                const optionCible = questionConfigCible.parametres.options[optionIndex];
                _aiguillerCalcul(questionConfigCible.parametres.mode, optionCible.libelle, questionConfigCible.parametres, resultats);
              }
            });
          }
        }
      }
    }
  }

  // ==================== DÃ‰BUT DE LA MODIFICATION FINALE ====================
  // La dÃ©termination du profil final se fait une seule fois Ã  la fin.
  if (Object.keys(resultats.scoresData).length > 0) {
    resultats.profilFinal = _determinerProfilFinal(resultats.scoresData, config.Type_Test, langueCible);
    
    // On rÃ©cupÃ¨re TOUTES les donnÃ©es du profil final
    const toutesLesDonneesDuProfil = profilsMap[resultats.profilFinal];

    if (toutesLesDonneesDuProfil) {
      // On fusionne les donnÃ©es du profil (Titre_Profil, Description_Profil, ConseilCarriere, etc.)
      // avec l'objet de rÃ©sultats existant.
      resultats = { ...resultats, ...toutesLesDonneesDuProfil };
    }
    
    // On garde cette map pour la brique Ligne_Score si besoin
    resultats.mapCodeToName = _creerMapCodeVersNom(profilsMap);
  }
  // ===================== FIN DE LA MODIFICATION FINALE =====================

  Logger.log("Calculs terminÃ©s. RÃ©sultats : " + JSON.stringify(resultats));
  return resultats;
}


/**
 * ExÃ©cute la logique de calcul sur un jeu de rÃ©ponses et une configuration de questions.
 */
function _executerCalcul(reponses, questionsMap, resultats) {
    for (const enTeteComplet in reponses) {
        if (!enTeteComplet.includes(':')) continue;
        const idQuestion = enTeteComplet.split(':')[0].trim();
        const questionConfig = questionsMap[idQuestion];
        if (questionConfig) {
            const reponse = reponses[enTeteComplet];
            const mode = questionConfig.parametres.mode;
            const parametres = questionConfig.parametres;
            _aiguillerCalcul(mode, reponse, parametres, resultats);
        }
    }
}


/**
 * Aiguille le calcul vers la bonne sous-fonction en fonction du mode de traitement.
 */
function _aiguillerCalcul(mode, reponse, parametres, resultats) {
    switch (mode) {
      case 'QCU_DIRECT': _traiterQCU_DIRECT(reponse, parametres, resultats); break;
      case 'QCU_CAT': _traiterQCU_CAT(reponse, parametres, resultats); break;
      case 'QRM_CAT': _traiterQRM_CAT(reponse, parametres, resultats); break;
      case 'ECHELLE_NOTE': _traiterECHELLE_NOTE(reponse, parametres, resultats); break;
      default:
        Logger.log(`Mode de traitement inconnu ou non implÃ©mentÃ© : ${mode}`);
        break;
    }
}

// =================================================================================
// == SOUS-FONCTIONS DE CALCUL (une par mode de traitement)
// =================================================================================
// CES FONCTIONS RESTENT INCHANGÃ‰ES...
function _traiterQCU_DIRECT(reponseUtilisateur, parametres, resultats) {
  if (!parametres || !parametres.profil) return;
  resultats.scoresData[parametres.profil] = reponseUtilisateur;
}

function _traiterQCU_CAT(reponseUtilisateur, parametres, resultats) {
  if (!reponseUtilisateur || !parametres || !parametres.options) return;
  const optionTrouvee = parametres.options.find(opt => opt.libelle === reponseUtilisateur);
  if (optionTrouvee && optionTrouvee.profil) {
    const profil = optionTrouvee.profil;
    const valeur = (typeof optionTrouvee.valeur === 'number') ? optionTrouvee.valeur : 1;
    resultats.scoresData[profil] = (resultats.scoresData[profil] || 0) + valeur;
  }
}

function _traiterQRM_CAT(reponseUtilisateur, parametres, resultats) {
  if (!reponseUtilisateur || !parametres || !parametres.options) return;
  const reponsesArray = String(reponseUtilisateur).split(',').map(r => r.trim());
  reponsesArray.forEach(reponse => {
    const optionTrouvee = parametres.options.find(opt => opt.libelle === reponse);
    if (optionTrouvee && optionTrouvee.profil && typeof optionTrouvee.valeur === 'number') {
      const profil = optionTrouvee.profil;
      const valeur = optionTrouvee.valeur;
      resultats.scoresData[profil] = (resultats.scoresData[profil] || 0) + valeur;
    }
  });
}

function _traiterECHELLE_NOTE(reponseUtilisateur, parametres, resultats) {
  if (!parametres || !parametres.profil) return;
  const valeurNumerique = parseInt(reponseUtilisateur, 10);
  if (!isNaN(valeurNumerique)) {
    const profil = parametres.profil;
    resultats.scoresData[profil] = (resultats.scoresData[profil] || 0) + valeurNumerique;
  }
}

// =================================================================================
// == FONCTIONS UTILITAIRES INTERNES
// =================================================================================
// CES FONCTIONS RESTENT INCHANGÃ‰ES...
function _determinerProfilFinalParSeuils(scoresData, typeTest, langue) {
  try {
    const systemIds = getSystemIds();
    const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
    const nomFeuilleProfils = `Profils_${typeTest}_${langue}`;
    const sheetProfils = bdd.getSheetByName(nomFeuilleProfils);
    if (!sheetProfils) return "";
    const dataProfils = sheetProfils.getRange("A2:C" + sheetProfils.getLastRow()).getValues();
    const totalPoints = Object.values(scoresData).reduce((sum, val) => sum + val, 0);
    if (totalPoints === 0) return "";
    const profilMajoritaire = Object.keys(scoresData).reduce((a, b) => scoresData[a] > scoresData[b] ? a : b);
    const scoreMajoritaire = scoresData[profilMajoritaire];
    const pourcentage = (scoreMajoritaire / totalPoints) * 100;
    for (const row of dataProfils) {
      const nomProfil = row[0];
      const conditionSeuil = row[1];
      if (!nomProfil || !conditionSeuil) continue;
      const codeProfilSeuil = conditionSeuil.split(' ')[0];
      if (codeProfilSeuil.toUpperCase() !== profilMajoritaire.toUpperCase()) continue;
      if (conditionSeuil.includes('>=')) {
        const seuil = parseFloat(conditionSeuil.replace(/[^0-9.]/g, ''));
        if (pourcentage >= seuil) return nomProfil;
      } else if (conditionSeuil.includes('<=')) {
        const seuil = parseFloat(conditionSeuil.replace(/[^0-9.]/g, ''));
        if (pourcentage <= seuil) return nomProfil;
      } else if (conditionSeuil.includes('-')) {
        const parts = conditionSeuil.match(/(\d+)-(\d+)/);
        if (parts) {
          const min = parseInt(parts[1], 10);
          const max = parseInt(parts[2], 10);
          if (pourcentage >= min && pourcentage <= max) return nomProfil;
        }
      }
    }
    return profilMajoritaire;
  } catch (e) {
    Logger.log("Erreur dans _determinerProfilFinalParSeuils: " + e.message);
    return "";
  }
}

function _determinerProfilFinal(scoresData, typeTest, langue) {
  if (!scoresData || Object.keys(scoresData).length === 0) return "";
  const testsAvecSeuils = ["r&K_Adaptabilite", "r&K_Resilience", "r&K_Creativite"];
  if (testsAvecSeuils.some(t => typeTest.toUpperCase() === t.toUpperCase())) {
    return _determinerProfilFinalParSeuils(scoresData, typeTest, langue);
  }
  if (typeTest.toUpperCase() === 'MBTI') {
    let profil = "";
    profil += (scoresData.E || 0) > (scoresData.I || 0) ? 'E' : 'I';
    profil += (scoresData.S || 0) > (scoresData.N || 0) ? 'S' : 'N';
    profil += (scoresData.T || 0) > (scoresData.F || 0) ? 'T' : 'F';
    profil += (scoresData.J || 0) > (scoresData.P || 0) ? 'J' : 'P';
    return profil;
  } else {
    return Object.keys(scoresData).reduce((a, b) => scoresData[a] > scoresData[b] ? a : b);
  }
}

function _creerMapCodeVersNom(profilsMap) {
    const map = {};
    for (const code in profilsMap) {
        // MODIFIÃ‰ : On cherche la clÃ© 'Titre_Profil' ou une clÃ© similaire
        map[code] = profilsMap[code].Titre_Profil || profilsMap[code].titre || code;
    }
    return map;
}

function _chargerQuestions(typeTest, langue) {
  try {
    const systemIds = getSystemIds();
    const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
    const nomFeuille = `Questions_${typeTest}_${langue}`;
    const sheet = bdd.getSheetByName(nomFeuille);
    if (!sheet) throw new Error(`Feuille introuvable: ${nomFeuille}`);
    const data = sheet.getDataRange().getValues();
    const headers = data.shift();
    const idCol = headers.indexOf('ID');
    const paramsCol = headers.indexOf('ParamÃ¨tres (JSON)');
    if (idCol === -1 || paramsCol === -1) throw new Error("Colonnes ID ou 'ParamÃ¨tres (JSON)' manquantes.");
    const questionsMap = {};
    data.forEach(row => {
      const id = row[idCol];
      const paramsJSON = row[paramsCol];
      if (id && paramsJSON) {
        try {
          const parametres = JSON.parse(paramsJSON);
          if (parametres.mode) { questionsMap[id] = { id: id, parametres: parametres }; }
        } catch (e) { Logger.log(`Erreur parsing JSON pour ID '${id}': ${e.message}`); }
      }
    });
    return questionsMap;
  } catch (e) {
    Logger.log("Erreur critique _chargerQuestions: " + e.message);
    return null;
  }
}

// =================================================================================
// == DÃ‰BUT DE LA SECTION PRINCIPALE MODIFIÃ‰E
// =================================================================================

/**
 * Charge les profils depuis la BDD et retourne un objet oÃ¹ chaque clÃ© est un code de profil
 * et chaque valeur est un objet contenant TOUTES les donnÃ©es de la ligne correspondante.
 * @param {string} typeTest Le type de test.
 * @param {string} langue La langue des profils Ã  charger.
 * @returns {object} Une carte des profils avec toutes leurs donnÃ©es.
 */
function _chargerProfils(typeTest, langue) {
  try {
    const systemIds = getSystemIds();
    const bdd = SpreadsheetApp.openById(systemIds.ID_BDD);
    const nomFeuille = `Profils_${typeTest}_${langue}`;
    const sheet = bdd.getSheetByName(nomFeuille);
    if (!sheet) throw new Error(`Feuille introuvable: ${nomFeuille}`);

    const data = sheet.getDataRange().getValues();
    const headers = data.shift();
    const profilsMap = {};

    // Trouve la colonne qui sert de clÃ© (Code_Profil ou Profil)
    const codeColIndex = headers.indexOf('Code_Profil') > -1 ? headers.indexOf('Code_Profil') : headers.indexOf('Profil');
    if (codeColIndex === -1) throw new Error("Colonne 'Code_Profil' ou 'Profil' introuvable.");

    data.forEach(row => {
      const codeProfil = row[codeColIndex];
      if (codeProfil) {
        profilsMap[codeProfil] = {}; // CrÃ©e un objet pour ce profil
        // Boucle sur toutes les colonnes pour remplir l'objet
        headers.forEach((header, index) => {
          if (header) {
            profilsMap[codeProfil][header] = row[index];
          }
        });
      }
    });
    
    return profilsMap;
  } catch (e) {
      Logger.log("Erreur critique _chargerProfils: " + e.message + "\n" + e.stack);
      return {};
  }
}
// =================================================================================
// == FIN DE LA SECTION MODIFIÃ‰E
// =================================================================================
// --- Fin du fichier: Logique_Universel.js ---

// --- DÃ©but du fichier: RetraitementUI.html ---
<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <style>
      body { font-family: 'Roboto', Arial, sans-serif; padding: 0 20px; background-color: #f8f9fa; color: #3c4043; }
      h3 { font-size: 20px; font-weight: 500; color: #1a73e8; border-bottom: 1px solid #dadce0; padding-bottom: 8px; margin-top: 24px; }
      .form-group { margin-bottom: 16px; }
      label { font-size: 12px; font-weight: 700; color: #5f6368; display: block; margin-bottom: 4px; }
      input[type="text"], input[type="email"], select { width: 100%; padding: 8px; border: 1px solid #dadce0; border-radius: 4px; box-sizing: border-box; font-size: 14px; }
      input[type="text"][readonly] { background-color: #f1f3f4; color: #5f6368; }
      .button-group { margin-top: 24px; display: flex; justify-content: space-between; }
      button { padding: 10px 16px; border: none; border-radius: 4px; font-size: 14px; font-weight: 700; cursor: pointer; }
      #btn-lancer { background-color: #1a73e8; color: white; }
      #btn-annuler { background-color: #e8eaed; color: #5f6368; }
      #status { margin-top: 16px; font-size: 12px; color: #5f6368; padding: 8px; background-color: #e8f0fe; border-radius: 4px; text-align: center; display: none; }
      .hidden { display: none; }
    </style>
  </head>
  <body>
    <input type="hidden" id="row-index-data" value="<?= ligneActive ?>">
    
    <h3>Retraitement de RÃ©ponse</h3>

    <div id="info-section">
      <div class="form-group"> <label for="nom">NOM DU RÃ‰PONDANT</label> <input type="text" id="nom" readonly> </div>
      <div class="form-group"> <label for="email">E-MAIL DU RÃ‰PONDANT</label> <input type="text" id="email" readonly> </div>
      <div class="form-group"> <label for="langue-origine">LANGUE D'ORIGINE</label> <input type="text" id="langue-origine" readonly> </div>
    </div>
    
    <hr>
    
    <h3>Options</h3>
    <div id="options-section">
        <div class="form-group">
          <label for="langue-cible">FORCER LA LANGUE DE L'E-MAIL</label>
          <select id="langue-cible">
            <option value="FR">FranÃ§ais (FR)</option> <option value="EN">English (EN)</option> <option value="ES">EspaÃ±ol (ES)</option> <option value="DE">Deutsch (DE)</option>
          </select>
        </div>
        <div class="form-group">
         <label for="niveau-resultat">FORCER LE NIVEAU DE RÃ‰SULTAT</label>
         <select id="niveau-resultat">
           <option value="">Automatique (par dÃ©faut)</option>
           <option value="N1">Niveau 1</option>
           <option value="N2">Niveau 2</option>
           <option value="N3">Niveau 3</option>
         </select>
       </div>
       
       <div class="form-group">
         <label for="alias-expediteur">ALIAS D'EXPÃ‰DITION (LAISSER VIDE POUR DÃ‰FAUT)</label>
         <input type="email" id="alias-expediteur">
       </div>
       </div>
    
    <h3 style="margin-top: 20px; border-top: 1px solid #dadce0; padding-top: 16px;">Destinataires</h3>
    <div id="destinataires-section">
      <div class="form-group">
        <label style="display: flex; align-items: center; font-weight: normal;"> <input type="checkbox" id="check-repondant" style="margin-right: 8px; transform: scale(1.2);"> Envoyer au RÃ©pondant </label>
        <label style="display: flex; align-items: center; font-weight: normal; margin-top: 8px;"> <input type="checkbox" id="check-formateur" style="margin-right: 8px; transform: scale(1.2);"> Envoyer au Formateur </label>
        <label style="display: flex; align-items: center; font-weight: normal; margin-top: 8px;"> <input type="checkbox" id="check-patron" style="margin-right: 8px; transform: scale(1.2);"> Envoyer au Patron </label>
      </div>
      
      <div id="formateur-email-group" class="form-group hidden">
        <label for="email-formateur">E-MAIL DU FORMATEUR</label>
        <input type="email" id="email-formateur" placeholder="adresse.formateur@example.com">
      </div>
      
      <div id="patron-email-group" class="form-group hidden">
        <label for="email-patron">E-MAIL DU PATRON</label>
        <input type="email" id="email-patron" placeholder="adresse.patron@example.com">
      </div>

      <div class="form-group">
          <label for="email-test">AJOUTER UNE ADRESSE DE TEST</label>
          <input type="email" id="email-test" placeholder="adresse.test@example.com">
      </div>
    </div>

    <div class="button-group"> <button id="btn-annuler">Annuler</button> <button id="btn-lancer">ðŸš€ Lancer le Retraitement</button> </div>
    <div id="status">Chargement...</div>

    <script>
      window.onload = function() {
        const rowIndex = document.getElementById('row-index-data').value;
        
        const statusDiv = document.getElementById('status');
        const lancerBtn = document.getElementById('btn-lancer');
        
        const checkFormateur = document.getElementById('check-formateur');
        const formateurEmailGroup = document.getElementById('formateur-email-group');
        const checkPatron = document.getElementById('check-patron');
        const patronEmailGroup = document.getElementById('patron-email-group');

        // Fonctions de rappel
        function onDataReceived(data) {
          document.getElementById('nom').value = data.nomRepondant || 'Non trouvÃ©';
          document.getElementById('email').value = data.emailRepondant || 'Non trouvÃ©';
          document.getElementById('langue-origine').value = data.langueOrigine || 'Non dÃ©tectÃ©e';
          document.getElementById('langue-cible').value = data.langueOrigine || 'FR';
          
          // ==================== DÃ‰BUT MODIFICATION ====================
          document.getElementById('alias-expediteur').value = data.emailAlias || '';
          // ===================== FIN MODIFICATION =====================

          document.getElementById('check-repondant').checked = data.repondantActif;
          document.getElementById('check-formateur').checked = data.formateurActif;
          document.getElementById('check-patron').checked = data.patronActif;
          
          if (data.formateurEmail) {
            document.getElementById('email-formateur').value = data.formateurEmail;
          }
          formateurEmailGroup.classList.toggle('hidden', !data.formateurActif);
          
          if (data.patronEmail) {
            document.getElementById('email-patron').value = data.patronEmail;
          }
          patronEmailGroup.classList.toggle('hidden', !data.patronActif);

          statusDiv.style.display = 'none';
          lancerBtn.disabled = false;
        }

        function onLaunchSuccess(message) {
          statusDiv.textContent = message;
          setTimeout(() => google.script.host.close(), 3000); 
        }

        function onFailure(error) {
          statusDiv.textContent = "Erreur : " + error.message;
          statusDiv.style.backgroundColor = '#fce8e6';
          lancerBtn.disabled = false;
        }

        // Ã‰couteurs d'Ã©vÃ©nements
        checkFormateur.addEventListener('change', function() {
          formateurEmailGroup.classList.toggle('hidden', !this.checked);
        });
        checkPatron.addEventListener('change', function() {
          patronEmailGroup.classList.toggle('hidden', !this.checked);
        });
        
        document.getElementById('btn-lancer').addEventListener('click', function() {
          lancerBtn.disabled = true;
          statusDiv.style.display = 'block';
          
          const options = {
            rowIndex: rowIndex,
            langue: document.getElementById('langue-cible').value,
            niveau: document.getElementById('niveau-resultat').value,
            
            // ==================== DÃ‰BUT MODIFICATION ====================
            alias: document.getElementById('alias-expediteur').value.trim(),
            // ===================== FIN MODIFICATION =====================

            destinataires: {
              repondant: document.getElementById('check-repondant').checked,
              formateur: document.getElementById('check-formateur').checked,
              formateurEmail: document.getElementById('email-formateur').value.trim(),
              patron: document.getElementById('check-patron').checked,
              patronEmail: document.getElementById('email-patron').value.trim(),
              test: document.getElementById('email-test').value.trim()
            }
          };
          google.script.run.withSuccessHandler(onLaunchSuccess).withFailureHandler(onFailure).lancerRetraitementDepuisUI(options);
        });

        document.getElementById('btn-annuler').addEventListener('click', () => google.script.host.close());

        // Appel initial pour charger les donnÃ©es
        statusDiv.style.display = 'block';
        google.script.run.withSuccessHandler(onDataReceived).withFailureHandler(onFailure).getDonneesPourRetraitement(rowIndex);
      };
    </script>
  </body>
</html>
// --- Fin du fichier: RetraitementUI.html ---

// --- DÃ©but du fichier: Menu.js ---
// =================================================================================
// == FICHIER : Menu.gs
// == VERSION : 2.3 (Retour Ã  la saisie manuelle systÃ©matique du NÂ° de ligne)
// == RÃ”LE : CrÃ©e le menu et gÃ¨re l'ouverture de l'interface de retraitement.
// =================================================================================

/**
 * S'exÃ©cute Ã  l'ouverture de la feuille de calcul pour crÃ©er le menu personnalisÃ©.
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('âš™ï¸ Actions Usine')
    .addItem("Activer le traitement auto", "activerTraitementAutomatique")
    .addSeparator()
    // MODIFIÃ‰ : Appelle directement la fonction qui ouvre la boÃ®te de dialogue
    .addItem("Retraiter une rÃ©ponse...", "retraiterReponse_UI")
    .addToUi();
}

/**
 * Ouvre une boÃ®te de dialogue pour demander le numÃ©ro de la ligne Ã  retraiter.
 * C'est maintenant la fonction par dÃ©faut appelÃ©e par le menu.
 */
function retraiterReponse_UI() {
  const ui = SpreadsheetApp.getUi();
  const htmlOutput = HtmlService.createHtmlOutputFromFile('DialogueLigne.html')
    .setWidth(350)
    .setHeight(160);
  ui.showModalDialog(htmlOutput, 'Retraitement de RÃ©ponse');
}

/**
 * Ouvre la barre latÃ©rale de retraitement pour une ligne donnÃ©e.
 * Cette fonction est appelÃ©e par le code HTML de 'DialogueLigne.html'.
 */
function ouvrirSidebarPourLigne(rowIndex) {
  const ui = SpreadsheetApp.getUi();
  const template = HtmlService.createTemplateFromFile('RetraitementUI');
  template.ligneActive = rowIndex;
  const htmlOutput = template.evaluate()
    .setTitle("Retraitement - Ligne " + rowIndex)
    .setWidth(350);
  ui.showSidebar(htmlOutput);
}

/**
 * CrÃ©e le dÃ©clencheur "onFormSubmit" pour le traitement automatique.
 */
function activerTraitementAutomatique() {
  const ss = SpreadsheetApp.getActive();
  const triggers = ScriptApp.getUserTriggers(ss);
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'onFormSubmit') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  ScriptApp.newTrigger('onFormSubmit')
    .forSpreadsheet(ss)
    .onFormSubmit()
    .create();
  SpreadsheetApp.getUi().alert('âœ… DÃ©clencheur activÃ© ! Le traitement automatique des rÃ©ponses est maintenant opÃ©rationnel.');
}
// --- Fin du fichier: Menu.js ---

// --- DÃ©but du fichier: DialogueLigne.html ---
<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons1.css">
    <style>
      body { padding: 20px; font-family: Arial, sans-serif; text-align: center; }
      input { width: 100%; margin-bottom: 15px; }
      button { margin-left: 10px; }
    </style>
  </head>
  <body>
    <p>Entrez le numÃ©ro de la ligne Ã  retraiter :</p>
    <input type="text" id="row-input" autofocus>
    <div>
      <button class="action" onclick="submitRow()">OK</button>
      <button onclick="google.script.host.close()">Annuler</button>
    </div>

    <script>
      // Permet d'utiliser la touche "EntrÃ©e"
      document.getElementById('row-input').addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          submitRow();
        }
      });

      function submitRow() {
        const rowNum = document.getElementById('row-input').value;
        if (!isNaN(rowNum) && rowNum.trim() !== '' && parseInt(rowNum, 10) > 1) {
          // Appelle la fonction cÃ´tÃ© serveur pour ouvrir la barre latÃ©rale
          google.script.run.ouvrirSidebarPourLigne(parseInt(rowNum, 10));
          google.script.host.close(); // Ferme ce dialogue
        } else {
          alert('Veuillez entrer un numÃ©ro de ligne valide (supÃ©rieur Ã  1).');
        }
      }
    </script>
  </body>
</html>
// --- Fin du fichier: DialogueLigne.html ---

// --- DÃ©but du fichier: GestionTriggers.js ---
// =================================================================================
// == FICHIER : GestionTriggers.gs
// == VERSION : 1.0 (CrÃ©ation initiale)
// == RÃ”LE  : GÃ¨re la crÃ©ation et l'exÃ©cution des envois d'e-mails diffÃ©rÃ©s.
// =================================================================================

/**
 * Calcule le dÃ©lai en millisecondes Ã  partir d'une chaÃ®ne de caractÃ¨res (ex: "4h", "1j").
 * @param {string} valeurDelai - La chaÃ®ne de caractÃ¨res reprÃ©sentant le dÃ©lai.
 * @returns {number} Le dÃ©lai en millisecondes. Retourne 0 si le format est invalide.
 */
function _calculerDelaiEnMs(valeurDelai) {
  if (!valeurDelai || typeof valeurDelai !== 'string') return 0;

  const valeurNumerique = parseInt(valeurDelai.replace(/[^0-9]/g, ''), 10);
  if (isNaN(valeurNumerique)) return 0;

  if (valeurDelai.includes('h')) {
    return valeurNumerique * 60 * 60 * 1000; // Heures en millisecondes
  } else if (valeurDelai.includes('j')) {
    return valeurNumerique * 24 * 60 * 60 * 1000; // Jours en millisecondes
  } else if (valeurDelai.includes('min')) {
    return valeurNumerique * 60 * 1000; // Minutes en millisecondes
  }

  return 0; // Format non reconnu
}


/**
 * Programme l'envoi diffÃ©rÃ© de l'e-mail de rÃ©sultats.
 * CrÃ©e un dÃ©clencheur unique et sauvegarde les informations nÃ©cessaires.
 */
function programmerEnvoiResultats(rowIndex, langueCible, delai) {
  try {
    const delaiEnMs = _calculerDelaiEnMs(delai);
    if (delaiEnMs <= 0) {
      Logger.log(`DÃ©lai invalide ou nul (${delai}). Annulation de la programmation.`);
      return;
    }

    // Identifiant unique pour ce dÃ©clencheur et ses donnÃ©es
    const proprieteId = `envoiDiffere_${new Date().getTime()}_${rowIndex}`;

    // 1. Sauvegarder les informations nÃ©cessaires pour l'envoi
    const properties = PropertiesService.getScriptProperties();
    properties.setProperty(proprieteId, JSON.stringify({
      rowIndex: rowIndex,
      langueCible: langueCible
    }));

    // 2. CrÃ©er le dÃ©clencheur qui s'exÃ©cutera aprÃ¨s le dÃ©lai
    ScriptApp.newTrigger('envoyerEmailProgramme')
      .timeBased()
      .after(delaiEnMs)
      .create();

    Logger.log(`Envoi programmÃ© avec succÃ¨s pour la ligne ${rowIndex}. DÃ©lai : ${delai}. ID de propriÃ©tÃ© : ${proprieteId}`);

  } catch (e) {
    Logger.log(`ERREUR lors de la programmation de l'envoi pour la ligne ${rowIndex}: ${e.toString()}\n${e.stack}`);
  }
}

/**
 * Fonction exÃ©cutÃ©e par le dÃ©clencheur pour envoyer l'e-mail de rÃ©sultats.
 * @param {object} e - L'objet Ã©vÃ©nement passÃ© par le dÃ©clencheur.
 */
function envoyerEmailProgramme(e) {
  const properties = PropertiesService.getScriptProperties();
  const toutesLesProps = properties.getProperties();

  // On cherche la premiÃ¨re propriÃ©tÃ© correspondant Ã  un envoi diffÃ©rÃ©
  const proprieteId = Object.keys(toutesLesProps).find(key => key.startsWith('envoiDiffere_'));

  if (!proprieteId) {
    Logger.log("DÃ©clencheur d'envoi programmÃ© exÃ©cutÃ©, mais aucune propriÃ©tÃ© de tÃ¢che trouvÃ©e. Annulation.");
    return;
  }

  try {
    const donnees = JSON.parse(properties.getProperty(proprieteId));
    const { rowIndex, langueCible } = donnees;

    Logger.log(`ExÃ©cution de l'envoi programmÃ© pour la ligne ${rowIndex} (ID: ${proprieteId})`);

    // Reconstituer le contexte nÃ©cessaire
    const config = getTestConfiguration(); // Assurez-vous que cette fonction est accessible
    const reponse = _creerObjetReponse(rowIndex); // Et celle-ci aussi
    const langueOrigine = getOriginalLanguage(reponse);
    const resultats = calculerResultats(reponse, langueCible, config, langueOrigine);

    // Envoyer l'e-mail
    assemblerEtEnvoyerEmailUniversel(config, reponse, resultats, langueCible, {});

    // Nettoyage : supprimer la propriÃ©tÃ©
    properties.deleteProperty(proprieteId);
    Logger.log(`Nettoyage de la propriÃ©tÃ© ${proprieteId} terminÃ©.`);

  } catch (err) {
    Logger.log(`ERREUR FATALE lors de l'exÃ©cution de l'envoi programmÃ© (ID: ${proprieteId}): ${err.toString()}\n${err.stack}`);
    // On supprime quand mÃªme la propriÃ©tÃ© pour Ã©viter des erreurs en boucle
    properties.deleteProperty(proprieteId);
  } finally {
    // Nettoyage : supprimer le dÃ©clencheur qui vient de s'exÃ©cuter
    if (e && e.triggerUid) {
      const allTriggers = ScriptApp.getProjectTriggers();
      for (const trigger of allTriggers) {
        if (trigger.getUniqueId() === e.triggerUid) {
          ScriptApp.deleteTrigger(trigger);
          Logger.log(`DÃ©clencheur ${e.triggerUid} auto-dÃ©truit avec succÃ¨s.`);
          break;
        }
      }
    }
  }
}
// --- Fin du fichier: GestionTriggers.js ---

